# 1. 트리
### 1) 트리란?
- 데이터의 상-하 관계를 저장하는 자료 구조

#### 계층적 관계
- 회사 조직도, 컴퓨터 폴더 구조, 클래스 상속 관계가 계층적 관계의 예시다.
<img width="715" alt="스크린샷 2021-05-02 오후 4 12 54" src="https://user-images.githubusercontent.com/70195733/116805396-51f32a00-ab61-11eb-9ed9-d4f29224c63d.png">
<img width="831" alt="스크린샷 2021-05-02 오후 4 12 58" src="https://user-images.githubusercontent.com/70195733/116805399-5586b100-ab61-11eb-930c-b164c56386b1.png">

- 리스트, 딕셔너리 등은 계층적 관계를 표현하기 어렵다.
- 트리의 맨 위 노드를 root 노드라 한다.
- 트리 주요 용어 설명
<img width="871" alt="스크린샷 2021-05-02 오후 4 16 26" src="https://user-images.githubusercontent.com/70195733/116805473-d6de4380-ab61-11eb-80e3-30469eb894be.png">

```
root 노드(뿌리 노드): 트리의 시작 노드, 뿌리가 되는 노드를 말합니다. 보통 트리를 표현할 때 위 그림처럼 가장 위에 root 노드를 놓는 방식으로 나타냅니다.
부모 노드: 특정 노드의 직속 상위 노드입니다. 노드 G, J, K가 있는 노란색 박스를 살펴보면 G가 J와 K의 부모 노드입니다.
자식 노드: 특정 노드의 직속 하위 노드입니다. 부모 노드와 반대되는 개념인데요. 노드 G, J, K가 있는 노란색 박스를 살펴보면 J와 K가 G의 자식 노드입니다.
형제 노드: 같은 부모를 갖는 노드입니다. D와 E는 둘다 그 부모가 B죠? 이럴 때 D와 E는 서로 형제 노드입니다.
leaf 노드 (잎/말단 노드): 자식 노드를 갖고 있지 않은, 가장 말단에 있는 노드입니다. 트리의 끝에 있다고 해서 root(뿌리) 노드와 반대되는 표현으로 leaf(잎) 노드라고 부릅니다. 
위 그림에서 노란색 박스로 둘러싼 F가 leaf 노드입니다. F뿐만 아니라 D, H, I, J, K 모두 leaf 노드입니다.
깊이: 특정 노드가 root 노드에서 떨어져 있는 거리입니다. 깊이는 해당 노드로 가기 위해서 root 노드에서 몇 번 아래로 내려와야 하는지를 나타냅니다. 
예를 들어 위 그림에서 root 노드의 자식 노드인 B와 C는 깊이가 1입니다. D, E, F, G는 깊이가 2이고, H, I, J, K는 깊이가 3입니다. 
결국 깊이라는 건 특정 노드가 root 노드로부터 얼마나 멀리 떨어져 있는지를 나타냅니다.
레벨: 깊이 + 1. 깊이랑 거의 똑같은 개념입니다. 그냥 깊이에 1을 더한 값이죠. 레벨 1에 있는 노드들, 레벨 2에 있는 노드들… 이런식으로 특정 깊이인 노드들을 묶어서 표현할 때 사용하는 용어입니다.
높이: 트리에서 가장 깊이 있는 노드의 깊이입니다. 위 그림의 트리에서는 H, I, J, K가 가장 깊이 있는 노드들이고 그 깊이는 모두 3입니다. 그래서 트리의 높이는 3입니다.


부분 트리 (sub-tree): 현재 트리의 일부분을 이루고 있는 더 작은 트리를 말합니다. 
위 그림의 트리는 root 노드가 A인 트리입니다. 그런데 이 트리를 좀더 작은 단위로 쪼개보면 더 작은 부분 트리들을 발견할 수 있습니다. 
예를 들어 위 그림의 노란색 큰 박스 안을 보세요. 노란색 큰 박스 안에는 ‘C가 root 노드인 트리’가 있는데요. 
이런 걸 바로 부분 트리라고 합니다. 지금 C가 A의 오른쪽 자식이죠?
그래서 노란색 큰 박스 안에 있는 부분 트리를 A의 “오른쪽 부분 트리”라고 합니다. 
특정 노드를 root 노드라고 생각하고 바라본다면 여러 가지 부분 트리들을 발견할 수 있습니다. 
하나의 전체 트리에 여러 부분 트리들이 존재하는 겁니다.
```
### 2) 트리의 활용
- 계층적 관계가 있는 데이터를 컴퓨터에서 사용
- 컴퓨터 과학의 다양한 문제를 기발하게 해결(예. 정렬, 압축)
- 흔히 사용하는 여러 추상 자료형 구현


### 3) 이진트리
- 자식의 최대 수가 2인 트리.
- 왼쪽 자식과 오른쪽 자식으로 나눠 관리

###  4) 이진트리의 종류
#### 정 이진 트리(Full Binary Tree)
- 모든 노드가 2개 또는 0개의 자식을 갖는 이진 트리
<img width="798" alt="스크린샷 2021-05-02 오후 4 29 03" src="https://user-images.githubusercontent.com/70195733/116805796-bca56500-ab63-11eb-9507-f1c0b44f9394.png">
#### 완전 이진 트리(complete Binary Tree)
- 마지막 레벨 직전의 레벨까지는 모든 노드들이 다 채워진 트리
- 왼쪽부터 오른쪽 방향으로 노드들이 채워져야 함.
- 완전 이진 트리 안에 저장된 노드가 n개라고 할 때, 높이는 항상 lg(n)에 비례한다.
<img width="792" alt="스크린샷 2021-05-02 오후 4 29 59" src="https://user-images.githubusercontent.com/70195733/116805800-c0d18280-ab63-11eb-8433-46bbdb6319da.png">
<img width="823" alt="스크린샷 2021-05-02 오후 4 30 27" src="https://user-images.githubusercontent.com/70195733/116805803-c29b4600-ab63-11eb-9226-b7028d97d32c.png">
#### 포화 이진 트리(Perfect Binary Tree)
- 모든 레벨이 완벽하게 다 채워져 있는 트리
<img width="802" alt="스크린샷 2021-05-02 오후 4 31 35" src="https://user-images.githubusercontent.com/70195733/116805820-e5c5f580-ab63-11eb-8da6-dd5798600acf.png">
<img width="802" alt="스크린샷 2021-05-02 오후 4 32 37" src="https://user-images.githubusercontent.com/70195733/116805838-055d1e00-ab64-11eb-9ff3-3cb121d32d31.png">

### 5) 트리 순회
- 트리 순회는 보통 재귀 함수를 쓴다.
#### 순회 기본 동작
- 재귀적으로 왼쪽 부분 트리 순회
- 재귀적으로 오른쪽 부분 트리 순회
- 현재 노드 데이터 출력

#### pre-order 순회
- 현재 노드 데이터를 출력한다.
- 재귀적으로 왼쪽 부분 트리 순회
- 재귀적으로 오른쪽 부분 트리 순회
![스크린샷 2021-05-05 오후 8 53 41](https://user-images.githubusercontent.com/70195733/117136950-000e0680-ade4-11eb-9052-d68f665645c3.png)
#### post-order 순회
- 재귀적으로 왼쪽 부분 트리 순회
- 재귀적으로 오른쪽 부분 트리 순회
- 현재 노드 데이터를 출력
![스크린샷 2021-05-05 오후 8 52 20](https://user-images.githubusercontent.com/70195733/117136775-cccb7780-ade3-11eb-8e21-8363839d96e8.png)
#### in-order 순회
- 재귀적으로 왼쪽 부분 트리 순회
- 현재 노드 데이터를 출력
- 재귀적으로 오른쪽 부분 트리 순회
- 코드로 구현
```
class Node:
    """이진 트리 노드를 나타내는 클래스"""

    def __init__(self, data):
        """이진 트리 노드는 데이터와 두 자식 노드에 대한 레퍼런스를 갖는다"""
        self.data = data
        self.left_child = None
        self.right_child = None

def traverse_inorder(node):
    """in-order 순회 함수"""
    if node is not None:
        traverse_inorder(node.left_child)  # 재귀적으로 왼쪽 부분 트리 순회
        print(node.data)  # 데이터 출력
        traverse_inorder(node.right_child)  # 재귀적으로 오른쪽 부분 트리 순회

```

#### pre-order 순회 함수
```
def traverse_preorder(node):
    """post-order 순회 함수"""
    if node is not None:
        print(node.data)  # 데이터 출력
        traverse_preorder(node.left_child)  # 재귀적으로 왼쪽 부분 트리 순회
        traverse_preorder(node.right_child)  # 재귀적으로 오른쪽 부분 트리 순회
```

#### post-order 순회 함수
```
def traverse_preorder(node):
    """post-order 순회 함수"""
    if node is not None:
        print(node.data)  # 데이터 출력
        traverse_preorder(node.left_child)  # 재귀적으로 왼쪽 부분 트리 순회
        traverse_preorder(node.right_child)  # 재귀적으로 오른쪽 부분 트리 순회
```
# 2. 힙
#### 힙이란?
- 힙은 완전 이진 트리다.
- 따라서 높이는 O(lg(n))이다.
- 힙 속성: 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다.
![스크린샷 2021-05-05 오후 10 26 24](https://user-images.githubusercontent.com/70195733/117148165-f0e18580-adf0-11eb-986c-990f6ca37cfb.png)

### 힙-정렬
- 정렬 알고리즘은 데이터를 재배치하는 구체적인 방법이다.
- 삽입 정렬, 선택 정렬, 퀵 정렬, 합병 정렬 등이 있다.
- [4,1,6,2,8,5] 같이 순서가 없는 데이터를 오름차순 혹은 내림차순 처럼 규칙 가지고 정렬하는 것.

#### 힙 구현하기
- 완전 이진 트리이므로 보통 동적 배열로 구현!(파이썬 리스트)
![스크린샷 2021-05-06 오후 10 26 07](https://user-images.githubusercontent.com/70195733/117306910-10dd7b80-aebb-11eb-9de8-d42b2c6fc67d.png)
#### heapify
- 부모 노드를 인자로 받는다.
- 왼쪽 자식, 오른쪽 자식 중 부모보다 큰 값이 있다면 가장 큰 값을 부모와 바꿔준다.(부모가 제일 크다면 가만히 있는다.)
- 이 작업을 반복한다.
- 시간복잡도: 최악의 경우 루트에 가장 작은 숫자가 옴 -> 트리의 높이만큼 걸림 -> O(lg(n))
- 노드 맨 뒤부터 모든 노드를 heapify를 하면 총 시간 복잡도는 n * lg(n) -> O(nlg(n))

#### 힙정렬(오름차순)
1. 힙을 만든다.
2. root와 마지막 노드를 바꿔준다.
3. (바꾼 노드를 없는 노드 취급한다.)
4. 새로운 노드가 힙 속성을 지킬 수 있게 heapify 호출
모든 인덱스를 돌 때 까지 2~4를 반복한다.

#### 힙정렬 시간복잡도
<img width="907" alt="스크린샷 2021-05-09 오전 9 14 41" src="https://user-images.githubusercontent.com/70195733/117556736-10a1d380-b0a7-11eb-9dc4-9ca8cb257a28.png">
<img width="889" alt="스크린샷 2021-05-09 오전 9 14 50" src="https://user-images.githubusercontent.com/70195733/117556739-14cdf100-b0a7-11eb-9566-52170ecedc7b.png">

### 우선순위 큐
- 힙은 힙정렬과 우선순위 큐에 주로 쓰인다.
- 우선 순위큐는 추상 자료형이다(추상자료형: 내부적인 구현보다 기능에 집중하게 해주는 개념)
- 우선순위 큐 기본 기능
  - 데이터를 저장
  - 저장한 데이터가 우선순위 순서대로 출력
- 예시
  - 높은 숫자가 우선순위인 큐에 2,5,3,7 데이터가 들어가면 출력 순서는 7,5,3,2이다.
#### 힙에 데이터 삽입하기
- 우선순위 큐를 만드려면 힙에 데이터를 삽입하는 방법을 알아야 한다.
- 힙에 데이터 삽입하기
  - 힙의 마지막 인덱스에 데이터 삽입
  - 삽입한 데이터와 부모 노드의 데이터 비교
  - 부모 노드의 데이터가 더 작으면 둘의 위치 바꿈
  - 힙 속성에 부합할 때까지 2,3번을 반복. 
- 시간 복잡도: O(lg(n))
  
 #### 힙에서 최고 우선순위 데이터 추출하기
- root 노드와 마지막 노드를 서로 바꿔준다.
- 마지막 노드의 데이터를 변수에 저장한다.
- 마지막 노드를 삭제한다.
- root 노드에 heapify를 호출해 망가진 힙속성을 고친다.
- 시간 복잡도: O(lg(n))
  
#### 우선순위큐 비교(힙 vs 동적 배열 vs 더블리 링크드 리스트) 
![스크린샷 2021-05-09 오후 11 51 19](https://user-images.githubusercontent.com/60768642/117576629-919db100-b121-11eb-966d-46f2eb90d24b.png)
- 삽입연산이 많다면 힙으로, 추출 연산이 많다면 동적 배열이나 더블리 링크드 리스트로 우선순위 큐를 구현하는 것이 좋다.

  
  
  
# 3. 이진 탐색 트리
#### 이진 탐색 트리란?