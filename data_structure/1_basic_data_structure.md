# 1. 컴퓨터가 데이터를 저장하는 방법
## storage vs memory
### 1. storage
- 테이터가 영구적으로 저장되는 곳
- 컴퓨터에 저장된 음악, 파일, 사진 등 유저가 직접 지우지 않는 이상 지워지지 않음.
- 데이터를 저장하고 받아오는 데 오래 걸린다.(느리다)
### 2. memory
- 데이터를 임시적으로 저장하는 곳
- 데이터 저장과 읽기가 빠르다.
- 작업중이던 워드 파일이 컴퓨터가 꺼지면 날라가는 이유는 메모리에 있기 때문.
- 저장 버튼을 누르면 이 파일이 스토리지로 넘어간다.
- 자료구조에서 다루는 것은 memory다. 

## RAM(Random Access Memory)
- 메모리는 일정한 칸으로 나눠져 있다.
- 메모리의 각 칸에 데이터를 저장할 수 있다.
- 메모리의 각 칸은 자신만의 주소가 있다.
![스크린샷 2021-04-19 오후 10 04 01](https://user-images.githubusercontent.com/60768642/115240922-33516400-a15b-11eb-8a2b-22520e8b8aa4.png)
- 메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위는 바이트(byte)다.
- 정확히 얼마만큼의 정보를 저장하는지까지 알 필요는 없고, 엄청 작은 단위 라는 정도만 일단 알자.
  - 킬로 바이트 = 1,000 바이트
  - 메가 바이트 = 1,000,000 바이트
  - 기가 바이트 = 1,000,000,000 바이트
- RAM은 임의접근 메모리다. 
- 임의접근이란 저장위치를 알면 접근할 때 항상 일정한 시간이 걸린다는 뜻이다. -> 시간복잡도 O(1)

## reference: x=95에 담긴 깊은 의미
### `x=95`
- 파이썬에선 x는 95다라고 말하면 틀린 답이다.
- x는 95를 가리킨다가 더 맞는 말이다.
- ***x = 5 이 파이썬 코드에서 x는 5라는 데이터 자체를 담고 있는게 아니라 5가 저장된 곳의 레퍼런스를 갖고 있다***
- x=95에서 x는 95가 저장된 메모리 주소다.
- 이렇게 데이터에 접근하게 해주는 값을 reference라고 한다.
- 사실 주소와 레퍼런스는 다른 개념이다.
- 주소는 메모리의 실직적 주소를 의마하고, 레퍼런스 데이터에 접근할 수 있게 해주는 값으로, 보다 포괄적인 표현이다.
- 하지만 자료구조를 배울 땐 "주소 = 레퍼런스" 라고 생각해도 무방하다.
```
x = 95
print(x + 5)
```
- 위 코드에서 x는 95의 레퍼런스이다.
- 그럼 95의 레퍼런스와 5를 더하게 되는 걸까?
- 파이썬은 똑똑해서 실제 변수를 사용할 때는 저장된 값을 알아서 받아와서 연산한다.
- 이런 기능 떄문에 마치 x가 95라고 생각하게 된다. 하지만 레퍼런스다!

### id 함수
- id 함수를 통해 저장한 데이터의 메모리 주소를 정수로 표현한 값을 알 수 있다.
```
# 리스트를 정의한다
list1 = [1, 2]
list3 = [1, 2, 3]
    
# Aliasing을 통해 list1과 list2를 같게 한다
list2 = list1
    
# 두 데이터의 메모리를 출력한다
print(id(list1))  # 140657629409160
print(id(list2))  # 140657629409160
print(id(list3))  # 140657629409096
```
- 위 코드에서 list1과 2는 같은 주소를 가리킨다.
- 이렇게 여러 변수가 같은 메모리를 가리키는 것을 Aliasing이라고 한다.

# 2. 배열
## 1) C언어 배열
### C언어 배열
- 크기가 고정되어 있다.(크기를 정해주고 시작한다.)
- 배열의 각 요소를 수정할 수 있지만, 지우거나 삭제할 수 없다.
- 같은 타입의 데이터만 담을 수 있다.
- 배열의 요소들이 ***순서대로, 연속적으로*** 저장된다.
#### `int numArray[4];`
- 정수 4개를 담을 수 있는 배열을 만드는 코드다.
- 배열이 쓸 공간을 미리 예약해야 한다.
- c에선 정수 하나 당 4바이트 이기 때문에 총 16칸(***연속적인***)을 예약한다.
![스크린샷 2021-04-19 오후 10 34 14](https://user-images.githubusercontent.com/60768642/115245038-7ad9ef00-a15f-11eb-9786-2f9eff38a0d5.png)
- 파이썬 리스트를 살펴보자.`num_list = [2,3,5,7]`가 있을 때 일단 2,3,5,7은 불연속적인 곳에 저장된다.
- 또한 2,3,5,7은 값이 아닌 값의 레퍼런스가 저장된 것이다.
- 따라서 배열 안에 각종 데이터 타입이 다 들어올 수 있다(예. `li = [2, "2", True]`)
- 값 자체가 아닌 reference를 저장하기 때문이다.
### 배열 인덱스 접근과 탐색
- 배열의 인덱스 접근은 O(1)이다. 
- 데이터 인덱스 접근 또한 시작주소만 알면 O(1)으로 가능하다.
- 임의 접근 RAM의 특성을 잘 활용한 것이 배열이다.
![스크린샷 2021-04-19 오후 10 41 57](https://user-images.githubusercontent.com/60768642/115246070-85e14f00-a160-11eb-8570-04b1de85d0d1.png)
- 배열의 탐색은 O(n)이다.
- 앞에서부터 순서대로, 선형탐색으로 찾아가야 하기 떄문이다.

## 2) 정적 배열
- 크기 고정(요소 수 제한)
- 5개의 값이 저장된 배열에 값 하나를 추가하려면, 이 배열은 6개가 들어갈 수 있는 새로운 공간을 찾아 이사를 간다.
- 배열을 정의할 때부터 미리 공간을 여유롭게 저장하면 되지 않냐고 되물을 수 있지만 이렇게 하면 메모리 낭비가 발생한다.
![스크린샷 2021-04-19 오후 10 55 53](https://user-images.githubusercontent.com/60768642/115248154-68ad8000-a162-11eb-85b3-2342afd3ba11.png)

## 3) 동적 배열(Dynamic array)
- 값이 고정되지 않은 배열로, 삽입, 삭제가 가능하다.
- 동적 배열은 사실상 정적 배열을 이용해서 만들어졌다.
- 동적 배열을 활용해 만들어진 자료구조이다.
- 정적 배열의 크기를 상황에 맞게 조절한다는 의미에서 이름이 동적 배열로 지어졌다.
- 파이썬의 리스트는 동적배열이다.
### 동적 배열 추가(append)연산 시간 복잡도
1) 정적 배열에 남는 공간이 있을 때: O(1)
2) 정적 배열이 꽉 찼을 때: O(n)

### 분할 상환 분석 


# 3. 링크드 리스트
# 4. 해시 테이블
# 5. 추상 자료형
#### 파이썬 리스트는 동적 배열로 구현되어있다.
![스크린샷 2021-05-02 오후 1 21 59](https://user-images.githubusercontent.com/70195733/116801919-662b2d00-ab49-11eb-9c23-b9c27670daad.png)

### 큐(Queue)
- 테이터간 순서 관계를 유지할 수 있다.
- 맨 뒤 데이터 추가
- 맨 앞 데이터 삭제
- 맨 앞 데이터 접근

#### python deque
- Doubly-ended-queue의 약자
- 맨 앞과 뒤에 데이터 삽입하고 삭제할 수 있게 해주는 자료형

```
from _collections import deque

queue = deque()

# queue에 데이터 삽입
queue.append(1)
queue.append(2)
queue.append(3)
queue.append(4)

# queue 인덱스 접근
print(queue[0])
print(queue[-1])

# queue 맨 앞 데이터 삭제(삭제된 데이터 리턴)
print(queue.popleft())
```
- 파이썬 deque는 내부적으로 더블리 링크드 리스트로 구현되어있다.
- 큐 앞,뒤에 삽입-삭제를 하기 때문에 동적 배열보다 더블리 링크드 리스트가 더 유리하다.
![스크린샷 2021-05-02 오후 1 41 12](https://user-images.githubusercontent.com/70195733/116802209-20239880-ab4c-11eb-805f-172dca54198c.png)
![스크린샷 2021-05-02 오후 1 41 17](https://user-images.githubusercontent.com/70195733/116802214-231e8900-ab4c-11eb-8c95-2b406d2d04c2.png)


### 스택(Stack)
- LIFO
- 데이터간 순서 관계를 유지할 수 있다.
- 맨 뒤 데이터 추가
- 맨 뒤 데이터 삭제
- 맨 뒤 데이터 접근
- 예시: 워드에서 최종 실행 동작 취소기능은 스택으로 구현될 수 있다.
```
from _collections import deque

queue = deque()

# queue에 데이터 삽입
queue.append(1)
queue.append(2)
queue.append(3)
queue.append(4)

# queue 인덱스 접근
print(queue[-1])

# queue 맨 앞 데이터 삭제(삭제된 데이터 리턴)
print(queue.pop())
```
- 위 예시에선 deque를 썼다. deque는 더블리 링크드 리스트로 구현됐다.
- 맨 뒤 삭제, 맨 뒤 삽입, 맨 앞 접근 이 세 연산은 더블리 링크드 리스트로 하던지, 동적 배열로 하던지 시간 복잡도가 같다.
- 파이썬에서 스택은 deque로 구현하던 list로 구현하던 시간 복잡도가 똑같다.
- 따라서 위 예시에서 deque대신 list로 바꿔도 문제 없다.
![스크린샷 2021-05-02 오후 1 54 49](https://user-images.githubusercontent.com/70195733/116802471-04b98d00-ab4e-11eb-8f79-cd5c6984e201.png)

### Set
- 파이썬 set는 내부적으로 hash table을 이용해 구현되어있다.
- hash_table에 value없이 key만 저장하는 형태다.
- 해시 테이블 특성상 삽입, 탐색, 삭제가 평균 O(1)이니, 속도가 엄청 빠르다.
<img width="883" alt="스크린샷 2021-05-02 오후 3 09 06" src="https://user-images.githubusercontent.com/70195733/116804255-5a933280-ab58-11eb-90f4-32bbec589bc8.png">

####  파이썬 자료형 주요 시간 복잡도 정리
<img width="772" alt="스크린샷 2021-05-02 오후 3 11 08" src="https://user-images.githubusercontent.com/70195733/116804294-a80f9f80-ab58-11eb-99ec-ad82cfc26ecb.png">
<img width="815" alt="스크린샷 2021-05-02 오후 3 11 12" src="https://user-images.githubusercontent.com/70195733/116804297-acd45380-ab58-11eb-965b-356cf669e64d.png">


### 파이썬 자료형 잘 고르기
- 리스트가 편하다고 무조건 리스트 먼저 떠올리면 안된다.
- 목적에 맞는 자료형 중 최적의 시간복잡도를 가진 자료형을 선택해야 한다.

```
# 예시를 위해 사용할 모듈 import
import time

# 데이터를 리스트에 저장한다
test_list = [x for x in range(0, 1000000)]

# 특정 항목이 리스트에 있는지 확인할 때 걸리는 시간 파악
t_0 = time.time()
999999 in test_list # 리스트 탐색
t_1 = time.time()

print(f"리스트에서 특정 항목을 찾는데 걸린 시간: {t_1 - t_0}")
```

`리스트에서 특정 항목을 찾는데 걸린 시간: 0.013087987899780273`

```
# 예시를 위해 사용할 모듈 import
import time

# 데이터를 set에 저장한다
test_set = set([x for x in range(0, 1000000)])

# 특정 항목이 set에 있는지 확인할 때 걸리는 시간 파악
t_0 = time.time()
999999 in test_set
t_1 = time.time()

print(f"세트에서 특정 항목을 찾는데 걸린 시간: {t_1 - t_0}")
```

`set에서 특정 항목을 찾는데 걸린 시간: 3.0994415283203125e-06`

- set는0.00000309초가 걸렸다.
- 엄청나게 큰 차이다.
- 자료형을 잘 골라야 한다.